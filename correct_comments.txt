const VGA_BUFFER: *mut u8 = 0xb8000 as *mut u8; // Pointer to the VGA text buffer (character and color info)
const BUFFER_WIDTH: usize = 80; // Number of text columns per row in VGA text mode
const BUFFER_HEIGHT: usize = 25; // Number of text rows in VGA text mode

// Function for printing ASCII art to the screen
fn print_ascii_art(art: &[u8], start_row: usize, start_col: usize, color: u8) {
    let mut row = start_row;
    let mut col = start_col;

    for &byte in art.iter() {
        // We use unsafe because we are manually accessing raw memory (the VGA buffer)
        unsafe {
            match byte {
                b'\n' => {
                    // Newline character: move to the beginning of the next row
                    row += 1;
                    col = 0;
                    if row >= BUFFER_HEIGHT {
                        // Stop printing if we're past the bottom of the screen
                        break;
                    }
                }
                _ => {
                    // Any printable character
                    if row >= BUFFER_HEIGHT || col >= BUFFER_WIDTH {
                        // Stop printing if we're outside the screen bounds
                        break;
                    }
                    let offset = (row * BUFFER_WIDTH + col) * 2;
                    // Write the character byte to VGA memory
                    *VGA_BUFFER.offset(offset as isize) = byte;
                    // Write the color attribute byte (foreground/background color)
                    *VGA_BUFFER.offset(offset as isize + 1) = color;
                    col += 1;
                }
            }
        }
    }
}

